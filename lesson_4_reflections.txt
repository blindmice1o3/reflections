"remote" means a remote repository (Github), and it's something we have to associate with our local Git repository. 

We can see a list of remotes ("git remote") just like we can see a list of branches ("git branch").

"git remote add origin https://github.com/blindmice1o3/reflections.git"
this command creates a remote, it adds a copy of our local repository to our remote (which is labeled as "origin") to a server (the argument with the url).

"git remote -v" -> this command will list all the remotes associated with our local repository, in a verbose manner (shows you more info than regular git remote)

"git push origin master" -> push the commits from my "master" branch onto the remote server labeled "origin"

by default, the branch pushed onto Github will have the same name as the branch from my local repository.

"git pull origin -> like git push, git pull needs to specify the "remote" (which we named "origin"), we also need to specify the branch we want to pull (which is the master branch on the remote)



Forking a repository (e.g. repository storing cooking recipes):
-Co-worker Larry has a repository of recipes (we like his recipes, but we still want to tweak it a little... and save it to share with our friends... but Larry doesn't want our little changes to save over his version of his recipes).
-We can do this on GitHub. We'll clone Larry's repository to Caroline's computer. This would automatically set up Larry's repository as a "remote" called "Origin". Then we could create a new repository on GitHub on Caroline's account. She could then set up this repository as a remote, which she could call whatever she wanted, say Our-version. She can then push the changes to the remote. And then since I (Sarah) want to contribute to this repository as well, I can clone it to my computer, setting up Caroline's version as origin. Anyone looking at our repository on GitHub has no way of knowing Larry's contribution (that it was his initially), unless it was explicitly mentioned.
-To do what we just did, GitHub has a feature called forking. This allows you to make a copy of somebody else's repository directly on the GitHub servers without pulling down the code to your local machine first. 
-You can fork an existing repository and have it appear under your own account with just a single click. Then to make your modifications, you'd likely want to pull down the code onto your own machine, unless the files are simple enough to edit directly on GitHub.
-Forking is a lot like cloning. In fact, a fork is just a clone that GitHub makes for you on their own machines. There are a few other side effects to forking. Like GitHub keeping track of the number of people who've made forks on your repository. And the forks all linking back to the original. It also makes it easier to suggest changes back to the original repository. 
-So since Larry's version is already on GitHub, forking makes a lot of sense in this case. Caroline can make the fork on her account. Then we can each clone our new version. The clones don't need to know anything about the original repository. 


Clone vs Branch vs Fork
-branching happens within the context of one repository.
-cloning is make a copy of the repository from the remote to your local machine (or a copy from your machine to your machine).
-forking is only on GitHub's servers (it makes a clone for you).


To fork the recipe repository, first I'll visit Larry's repository on GitHub. Click the fork button. Then a copy of the repository is made on my own GitHub profile. I'd like to be able to edit these recipes on my own computer rather than just on the GitHub website. So I'll also want to clone this fork. The GitHub page contains the URL I should clone, so I'll copy that URL, and paste it into my git clone command ("git clone [url]"). Then cd (change directory) into the recipes folder. You might think that I need to add the fork on GitHub as a remote so that I'll be able to push it, but actually when you clone a repository... Git automatically sets up a remote pointing to the repository you cloned from. I'll verify that by running "git remote -v". There's a remote called origin and the URL points to my repository on GitHub. Finally, since I want Sarah to be able to collaborate with me, she'll need permission to push to this repository. I'll add her as a collaborator by going to Setting, clicking Collaborators, and then adding her GitHub user name. You don't have to add Sarah to your repository, but this is where you would go to let people push onto your repository. 


Where was your commit present:
			 	BEFORE git push			AFTER git push
In your local repository	YES				YES
(visible via git log)
On your fork 			NO				YES
(visible via the commit history on GitHub)
On Larry's repository		NO				NO
(visible via the commit history on GitHub)

Before you ran git push, your change should have existed locally via git log. Commits will not automatically be shared to remotes, you have to manually push your branch if you want to share changes.
After you ran git push, your change should have existed locally and on your fork. It should not have existed on Larry's repository, which is the repository you forked. The reason you forked in the first place is because you don't have permission to change Larry's repository!

What happens if you had a local commit that hasn't been pushed to GitHub, but also have changes in GitHub (say a coworker contributed, so there's new commits) that aren't on your local machine. If we pull, would we lose our new local commit? What happens if we push when we're in this situation? What we want to happen when we pull is... we want git to keep our new local commits while intergrating the new commits we're pulling from GitHub (we want git to merge the local and remote version of the branch).
-we'll do this by changing the chili-recipe.txt (add a new spice to Ingredient, and change Step 2 to include that ingredient), see the changes using "git diff", add the changes to the staging area "git add chili-recipe.txt, and make a commit (but don't PUSH yet). Now when we run git status I can see my branch is ahead by one commit.
-a collaborator pushed a change to remove cumin from the chili-recipe.txt
-Since Sarah and I both modified the same lines though, Git is going to mark this as a conflict. On the next screen, you'll see some instructions to add Sarah's changes to your own fork. Then Sarah will go over how I can resolve this conflict.

Updating Local Copies of Remote Branches:
When you have a remote set-up, Git stores local copies of all the remote branches. These will each contain the state of the remote branch as of the last time you pushed or pulled the branch. 

We've already seen that when we clone a repository, you get a local branch called master, that points to the same commit as the remote one. 


***
But what you haven't seen yet is that you also get a local copy of the last known position of that branch on the remote. 

The name of that branch includes the name of the remote, origin, since you could have multiple remotes set up, as well as the name of the branch on the remote (in this case, master) with the two separated by a slash (origin/master).
***

*****
Let's consider what happen when we make a commit on the master branch locally. As usually, when you make a commit on a branch, that branch will get updated to point to the new commit. 

But, neither the local origin/master branch nor the actually master branch on the GitHub repository will get updated because you haven't communicated that you want to do that. 

However, if you push the master branch, the local origin/master branch and the remote GitHub branch will get updated with the new commit. 

Similarly, if this branch were to get updated on GitHub and then we pulled, both of these would get updated with the new commit.
*****

Let's go back to think about what happens when you've got different changes on each repository, with one change locally and another remote. It turns out that you can update just the local copy of the remote branch, leaving your actual local version alone, by running the command "git fetch".

In cases like this, where there are potentially conflicting changes, using "git fetch" to update the local copy of the remote branch can be nice, so that you can use git log and git diff to see what changes were introduced, both on the local and remote repositories. 

This way, if you're going to be offline for a while, say if you're about to get on a plane, you can update your local copy of the remote branch before you leave. And then you'll have access to any updates that have been made to the remote since you last synced up, while you were offline. But you don't have to act on combining those commits right away. 

Combining changes (now that we have the commit from GitHub on our local repository, it's now possible to incorporate them into your master branch using git merge). It turns out that this is exactly what happens when you do a git pull. First, the remote branch gets fetched, updating the local copy of the remote branch. Then, that branch gets merged into the local one. 
-Fetching updates origin/master with the contents of GitHub's master branch
-Then origin/master is merged into master
(git pull origin master => git fetch origin + git merge master origin/master)

-Update local copies by running git fetch origin, which will update all of the local copies of every branch for the origin remote.
-I can inspect the local copies by running "git log origin/master" or "git diff origin/master master".

Merging the Changes Together2:
-Since I've already run git fetch, my origin/master will contain Sarah's changes, which I can verify by running git status. As expected, I see that my branch and origin/master have diverged and have one and one different commit each.
-Now I'm ready to merge Sarah's changes into my local master. So, to do that, first I'll make sure I have the master branch checked out. And then I'll run git merge,and the two branches I want to merge are master and origin/master. 
-Like I expected, I got a merge conflict, so I'll open the file and resolve it. 
-So I can see here's the original version (before either of us made changes), here are my changes (with onion powder added), and here's Sarah's version (with cumin removed). I manually resolve the conflict and save the file.
-Finally, I'll let git know the conflict is resolved by adding the chili recipe and committing. 
-As usual, when I merge, Git creates an automatic commit message for me, this time letting me know that I've merged the remote-tracking branch 'origin/master'.
-Since running git pull is the same as running git fetch and then git merge, I could have run git pull origin master and the same thing would have happened.
-If I run this now, then I can see that master is already up-to-date, which makes sense.
-Now create a merged version of your version and Sarah's changes by running either git pull or both git fetch and git merge. Then push the merged version up to GitHub. Once you're finished, run git status and paste the output in this box.

Fast-Forward Merges:
-At this point you might have some questions. You might be wondering if git pull and the same as fetching and merging, why haven't our previous pulls generated commits like this one did? The answer is: fast-forward merges.
-This kind of merge occurs when you merge two commits, where one is ancestor of the other. That is, where one commit is reachable by the other.
-If all merges happened the way we've been showing you so far, if you took b and tried to merge it into a (git merge a b), then you would end up with a merge commit that had both commits as a parent, and you would move a (new a). 
-In the usual case, merge commits are generated to keep track of all the commits that played a part in getting to this stage. But in this case, the commits that played those parts are this one (b) and this one (previous a). And this commit (b) already has all the information about this one's (previous a) history. So there's no actual reason to add this extra one. So instead of adding a new commit, all we would do is update the label to point here (b) instead.
-Hopefully, at this point the name fast-forward merge makes sense.
-We're taking a label from the history of a branch somewhere in its ancestry, and moving that label forward to the tip of the branch. 
-Remember, the only criteria for whether something would be a fast-forward merge is if the branch you are merging into is an ancestor of the branch that you're merging from. 
-(opposite of fast-forward merge is merged commit???)

Reflection question about benefit of having a locally stored copy of the last known state of the remote.

Next, Caroline will introduce a GitHub feature called a "Pull-Request" that makes collaboration easier.

Making a Pull Request:
-Now that you've seen how to make changes public by sharing them on GitHub, I wanted to show you a work flow you can use to get feedback on your changes to a project before you update the master branch. 
-As an example, here is the recipes repository both locally on my own computer and my fork on GitHub. 
-If I have a change I want Sarah's feedback on, then first I'll make that change locally on a separate branch. Next, I'll push that change to my fork. Now my change is shared on GitHub, so Sarah can see it, but it's not in the master branch. That way if Sarah finds a problem with my change when she reviews it, I won't have broken master. 
-Next, I'll use a feature of GitHub called pull requests that make it easy for Sarah to see exactly what I've changed and leave comments.
-When we're both ready, I'll merge this change into the master branch. 
-Right now, I want to change the cake recipe to use canola oil instead of vegetable oil, since it's healthier. 
-First, I'll make a new branch called "different-oil" (git branch different-oil). Then I'll checkout that branch (git checkout different-oil), and go ahead and make the change. Now, I want to show Sarah the changes I've made, so I'll add them (git add cake-recipe.txt), commit them (git commit), and push them (git push origin different-oil). Note that this time I'm running git push origin different-oil to push the different-oil branch instead of master. 
-Now that I've pushed my branch, it's possible to see it on GitHub. To see what branches exist, I can choose this drop down, and I can see that right now I'm looking at the master branch. And here's the different-oil branch that I just pushed. This list of branches is the same list I would see if I ran get branch on the repository on GitHub. So only branches that I've pushed to GitHub will show up. To see what the files look like on the different-oil branch, I can click on it, which is analogous to running git checkout. Sarah could also do this and then view the commit history to see what changes I've made. 
-Instead though, I'm going to create a pull request for my changes. I'll go back to the main page for the repository, and I could click the compare and pull request button here since I just pushed the branch recently. But if I pushed it less recently and that button wasn't there, then I would checkout this branch, scroll down a little and click Pull Request. 
-By default, GitHub assumes I want to merge my changes into the original repository, which is Larry's repository. But instead, I want to merge my changes into the master branch of my own fork. So I'll scroll to the right and click Edit. And now I can change the base fork to cbuckey-uda/recipes. Now I'll scroll down and to the right, and click Create pull request. 
-Now, GitHub makes a view that shows all the commits that are present in this pull request and all the changes that have been made. If I go back up to the repository and scroll to the right, I can also see a list of all Pull Requests. So Sarah can check this list and see that I've liked to merge these changes into master. Now I'll turn you over to Sarah while she looks at my pull request.

-Since I'm watching Caroline's fork of recipes repository, I got an email notifying me when she made a pull request. I can click through in this email to see the pull request on GitHub. You might be wondering why these are called pull requests. 
-Caroline initiated this request, but she's not asking to pull anything. She's trying to merge one of her changes into master, or you might think of this as her trying to "push" into master. So why is it called a "pull request"?
-It's because she's requesting that I pull her branch into the master branch. Another good name for this might be "merge request".
-But "pull request" is what GitHub picked, so we'll go with that.
-So Caroline wants me to merge her different-oil branch into the master branch. Since the master branch is the main branch, and it's what people will see when they first come to the repository, I want to make sure that it really looks good before actually doing the merge. 
-It looks like she just changed vegetable to, oh, "canols"??? I think she meant "canola", based on the name of the pull request.
-I don't really want to merge this in because it has a spelling error. That would probably be confusing if anybody was looking at this later. So instead of merging it now, I'm actually going to leave a comment.
-I could put my comment here, commenting on the whole change, or I could do an inline comment here. I think I'll choose that option. 
-At this point, I'll go back to the main pull request. If there were more commits, I could look at them here, but since there's only one, I don't need to look at anything else. 
-If I had decided that the change was good, and ready to be pulled in right now, I could have pressed this Merge pull request button. 
-This will only appear when the merge could go through without a conflict. So it's a nice indicator to the person reviewing the changes, as to whether or not it's really ready to go. If the change would've created a merge conflict, I would ask Caroline to merge master into her branch first, so that I could see how she resolves the conflict. That way I know that when her code finally does get added to master, there's no chance that something's going to go wrong with a bad merge. 
-All right, at this point you should go ahead and make the change that Caroline described by creating a new branch off of master, and commiting a change that switches vegetable oil out in favor of canola. You can make a typo or other mistake on purpose so that you'll have a reason to update the pull request later. You don't have to. Go ahead and push your new branch to the fork, and then use GitHub to initiate a pull request, but make sure not to click the Merge button yet. 


Updating a Pull Request:
-I just got an email letting me know that Sarah commented on my pull request. She said that I misspelled canola. Well, I'll go take a look. "Canols" oil. Yeah that's not right. I'll go ahead and fix that. And I'll commit my fix. 
-Now since I want this change to be visible on GitHub also, I'll push (git push origin different-oil). 
-Pushing the branch automatically updates the pull request on GitHub. Underneath Sarah's comment about my misspelling you can see my commit fixing the typo. Also, if I look at the commits I can see there are two now. If I look at the files changed I can see the correct spelling. 
-Now I'd like you to follow the same steps and make a pull request on your own. First, create a new branch called different-oil, then make a commit on the different-oil branch to use canola oil instead of vegetable oil like I did. If you want, you can make a typo on purpose but that's optional. Then push your different-oil branch to your fork on GitHub and create a pull request. Make sure to change the base to the master branch of your repository and not Larry's repository. If you made a typo earlier, then make another commit to fix the typo and update the pull request. Finally, paste the link to your pull request in this box. You can find the link to your pull request by viewing your repository on GitHub, scrolling over to the right, and looking at the list of pull requests. Then click on your pull requests, and copy this URL from the URL bar. Finally, make sure you don't merge your pull request yet. If you do then a later exercise won't work. 


Conflicting Changes:
-Okay. Now that you've seen how to create a pull request, let's take a look at what happens when someone else makes changes that conflict with your pull request. Sarah has said that my pull request looks good, but she has also made a pull request. I can see it here in the list of pull requests. It looks like she increased the amount of oil to put in the cake so that it would be more moist. Since our changes affect the same line, git will mark them as a merge conflict, so one of us will have to resolve the conflict. I'll go back to this screen and merge Sarah's changes first, and then I'll need to resolve the merge conflict. Yes, confirm. And since Sarah only created the more oil branch in order to make this pull request into master, it's safe to delete the branch now. Now when I go back to my pull request, I see that it can't be automatically merged anymore. This is because performing a merge between the master branch and my branch would now cause merge conflicts. Rather than having you resolve the merge conflicts from the browser GitHub requires you to merge the changes on your own computer and send (update) the pull request with the merged version. Let's go to Sarah to talk about how you would do that. 
-Here's what the recipes repository looked like on GitHub before Caroline merged in my change. Notice that I've left some of the earlier changes out this time because I'm a little pressed for space. Here's the branch that I created to add more oil to the recipe. And here's Caroline's branch with the different kind of oil. With the misspelling, and the master at this point is still unchanged. And here's what the local version looks like. My changes aren't there because she hasn't pulled since the last time she pushed. What do you think happened in this diagram when Caroline clicked the button to merge my branch into master? You might be remembering when we talked about fast forward merges. And how since master is an ancestor of more oil. Master mmight just get updated to point to the tip of the more oil branch. That would be a great guess. That's actually what I would of expected, but it turns out that even if you could of had a fast forward merge, merging with the button on GitHub with always make a commit anyway even if no extra information is given by making that merge commit. After clicking the button to make this merge commit Caroline also deleted this branch. GitHub makes this very easy to do after a merge and it's pretty common to want to actually get rid of this branch cause usually it's named for the specific purpose that that branch was serving and once you merge it in, it's pretty much at the end of its life. So we'll go ahead and remove it from the diagram as well. So this is what GitHub looks like at this point. Now if Caroline wants to update her pull request to include my changes. If merging these two branches wouldn't cause a conflict, I could actually just pull in her request now. But since we changed the same lines, she's going to have to pull these changes over into her local version. So she'll need to pull master. This will update her local version with all the commits on master that aren't already on her version. So this one and this one. And it'll also update origin/master. There wasn't an obvious place to put this, since there's so many things attached to this commit. And I'm a little low on space. So, here's an arrow to show you that this is attached to this command. Remember, Caroline's eventual goal is to get her change into the master branch up on the GitHub repo. So, you might be tempted to think that she should just merge her branch into master and push it up. This is basically what happened the last time we had a merge conflict. But remember, this time we're using pull requests to communicate our changes to one another. So if Caroline just merged her branch into master and pushed it up, I wouldn't have a chance to check out her updates and make sure her changes still looked good before she updated master. In this collborative environment it's often only acceptable to make changes to master through pull request, since otherwise things can change out from under you without notification. So Caroline will need to make the fix to her branch. Fix the typo for canola, and then merge in master into her different oil branch. And then push her branch up to GitHub which will update the pull request so that I can look at that before merging it back into master. 

Quiz: Updating Your Local Repository
-So like Sarah said, the first step will be to get her changes into my local repository. Right now, if I run git log on the master branch, I don't see Sarah's commit. So I'll need to run git pull. And I'll pull from the origin remote in the master branch. Recall that if I wanted to take another look at Sarah's changes first, I could run git fetch, examine the changes, and then run git merge origin/master master. But since I already know what her changes are, I ran git pull instead. Now I want these changes to be incorporated into the different-oil branch, so I'll run git checkout different-oil, and then git merge master different-oil. As expected, I get a merge conflict. I'll resolve the conflict keeping both of our changes, so now there's three quarter of the cup of canola oil, and then I'll commit the merge. Now I'll run git log, and I can see that this branch contains both of our changes. Here's where the more oil pull request was merged, and here's the merge commit that I just made. Now go ahead and repeat these steps in your own repository. In order to get Sarah's changes to appear in your fork, you'll need to download and run the code we've provided in the downloadables section. There are instructions on how to do this in the instructor's notes. Now this code won't actually make a pull request, so you won't see a pull request appear in your repository. Instead, if you look at your commit history on GitHub, you should see a commit that looks like this one, saying, merge pull request. And you should also see Sarah's commit, adding more oil so the cake is moist. Once you've run the code to simulate Sarah's changes, update your local repository with Sarah's changes and merge your master branch into your different-oil branch, like I did. Finally, push your different-oil branch to your fork to update your pull request, which I haven't done yet. Once you're done, here are some things you can check to verify that everything has gone correctly. Your local master branch should contain Sarah's changes. Your local different-oil branch should contain the merge commit, merging Sarah's changes into your branch. The same merge commit should be visible on your pull request. And the merge button on your pull request should be green. Check these boxes once these things are true for you. 

Quiz: Merging a Pull Request
-Now I'll run git push origin different-oil. As you saw before, pushing the branch updates the pull request. So, now the pull request can be automatically merged. If I look at the changed files within the pull request, I still only see my changes. That's because this view only shows changes that are present in my branch, but not present in the master branch. And Sarah's changes are in both branches now. Finally, I'll leave another comment for Sarah, so she'll know to take another look and make sure everything looks good now. That's because GitHub will email Sarah, if I leave this comment. But it actually won't email her that I've updated the pull request, so I want to make sure she sees the update.


Concept Map: Fork, Fetch, Pull Request, Fast-Forward Merge
-




Q. When would you want to use a remote repository rather than keeping all your work local?
A. We may use a remote repository rather than keeping all our work local when we work collaboratively with team members or if we're using different (multiple) computers.

Q. Why might you want to always pull changes manually rather than having Git automatically stay up-to-date with your remote repository?
A. We may not want changes from other people working on the project just yet. Always pulling the changes manually rather than having Git automatically stay up-to-date with our remote repository will give us that control.

Q. Describe the differences between forks, clones, and branches.  When would you use one instead of another?
A. A fork is a GitHub feature that creates a clone of a repository onto its servers (as oppose to cloning it to your local machine). After the fork of a target repository is create onto your GitHub account (which is just a clone of the target repository), you can bring that repository to your local machine by cloning it with the command "git clone [url]" where the url is the forked repository from your GitHub account. The clone is just a copy of a repository. Branches are on a smaller scope, within one repository. We create branched versions of that one repository.

Q. What is the benefit of having a copy of the last known state of the remote stored locally?
A. The benefit of having a copy of the last known state of the remote stored locally is you can be offline and still be able to compare (git diff) your present working copy with the last known remote changes.

Q.How would you collaborate without using Git or GitHub?  What would be easier, and what would be harder?
A. Without using Git or GitHub, I would collaborate using email with attachments of my code files (the body of the email would explain the changes I've made so my collaborators will have something like a commit message). It would be harder to have my collaborators review my changes (to double check, make comments or suggestions) before I send it off as the final version. It would also be harder to maintain different versions of my project, switching back and fourth between changed versions, and I wouldn't have a centralized system of keeping my files' versions organized. Something that would be easier would be being flexible with starting and stopping points since having logical commit (chunks of functionality) isn't required.




Q. When would you want to make changes in a separate branch rather than directly in master?  What benefits does each approach have?
A.    Fill in your answer here
