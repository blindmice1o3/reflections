"remote" means a remote repository (Github), and it's something we have to associate with our local Git repository. 

We can see a list of remotes ("git remote") just like we can see a list of branches ("git branch").

"git remote add origin https://github.com/blindmice1o3/reflections.git"
this command creates a remote, it adds a copy of our local repository to our remote (which is labeled as "origin") to a server (the argument with the url).

"git remote -v" -> this command will list all the remotes associated with our local repository, in a verbose manner (shows you more info than regular git remote)

"git push origin master" -> push the commits from my "master" branch onto the remote server labeled "origin"

by default, the branch pushed onto Github will have the same name as the branch from my local repository.

"git pull origin -> like git push, git pull needs to specify the "remote" (which we named "origin"), we also need to specify the branch we want to pull (which is the master branch on the remote)



Forking a repository (e.g. repository storing cooking recipes):
-Co-worker Larry has a repository of recipes (we like his recipes, but we still want to tweak it a little... and save it to share with our friends... but Larry doesn't want our little changes to save over his version of his recipes).
-We can do this on GitHub. We'll clone Larry's repository to Caroline's computer. This would automatically set up Larry's repository as a "remote" called "Origin". Then we could create a new repository on GitHub on Caroline's account. She could then set up this repository as a remote, which she could call whatever she wanted, say Our-version. She can then push the changes to the remote. And then since I (Sarah) want to contribute to this repository as well, I can clone it to my computer, setting up Caroline's version as origin. Anyone looking at our repository on GitHub has no way of knowing Larry's contribution (that it was his initially), unless it was explicitly mentioned.
-To do what we just did, GitHub has a feature called forking. This allows you to make a copy of somebody else's repository directly on the GitHub servers without pulling down the code to your local machine first. 
-You can fork an existing repository and have it appear under your own account with just a single click. Then to make your modifications, you'd likely want to pull down the code onto your own machine, unless the files are simple enough to edit directly on GitHub.
-Forking is a lot like cloning. In fact, a fork is just a clone that GitHub makes for you on their own machines. There are a few other side effects to forking. Like GitHub keeping track of the number of people who've made forks on your repository. And the forks all linking back to the original. It also makes it easier to suggest changes back to the original repository. 
-So since Larry's version is already on GitHub, forking makes a lot of sense in this case. Caroline can make the fork on her account. Then we can each clone our new version. The clones don't need to know anything about the original repository. 


Clone vs Branch vs Fork
-branching happens within the context of one repository.
-cloning is make a copy of the repository from the remote to your local machine (or a copy from your machine to your machine).
-forking is only on GitHub's servers (it makes a clone for you).


To fork the recipe repository, first I'll visit Larry's repository on GitHub. Click the fork button. Then a copy of the repository is made on my own GitHub profile. I'd like to be able to edit these recipes on my own computer rather than just on the GitHub website. So I'll also want to clone this fork. The GitHub page contains the URL I should clone, so I'll copy that URL, and paste it into my git clone command ("git clone [url]"). Then cd (change directory) into the recipes folder. You might think that I need to add the fork on GitHub as a remote so that I'll be able to push it, but actually when you clone a repository... Git automatically sets up a remote pointing to the repository you cloned from. I'll verify that by running "git remote -v". There's a remote called origin and the URL points to my repository on GitHub. Finally, since I want Sarah to be able to collaborate with me, she'll need permission to push to this repository. I'll add her as a collaborator by going to Setting, clicking Collaborators, and then adding her GitHub user name. You don't have to add Sarah to your repository, but this is where you would go to let people push onto your repository. 


Where was your commit present:
			 	BEFORE git push			AFTER git push
In your local repository	YES				YES
(visible via git log)
On your fork 			NO				YES
(visible via the commit history on GitHub)
On Larry's repository		NO				NO
(visible via the commit history on GitHub)

Before you ran git push, your change should have existed locally via git log. Commits will not automatically be shared to remotes, you have to manually push your branch if you want to share changes.
After you ran git push, your change should have existed locally and on your fork. It should not have existed on Larry's repository, which is the repository you forked. The reason you forked in the first place is because you don't have permission to change Larry's repository!

What happens if you had a local commit that hasn't been pushed to GitHub, but also have changes in GitHub (say a coworker contributed, so there's new commits) that aren't on your local machine. If we pull, would we lose our new local commit? What happens if we push when we're in this situation? What we want to happen when we pull is... we want git to keep our new local commits while intergrating the new commits we're pulling from GitHub (we want git to merge the local and remote version of the branch).
-we'll do this by changing the chili-recipe.txt (add a new spice to Ingredient, and change Step 2 to include that ingredient), see the changes using "git diff", add the changes to the staging area "git add chili-recipe.txt, and make a commit (but don't PUSH yet). Now when we run git status I can see my branch is ahead by one commit.
-a collaborator pushed a change to remove cumin from the chili-recipe.txt
-Since Sarah and I both modified the same lines though, Git is going to mark this as a conflict. On the next screen, you'll see some instructions to add Sarah's changes to your own fork. Then Sarah will go over how I can resolve this conflict.

Updating Local Copies of Remote Branches:
When you have a remote set-up, Git stores local copies of all the remote branches. These will each contain the state of the remote branch as of the last time you pushed or pulled the branch. 

We've already seen that when we clone a repository, you get a local branch called master, that points to the same commit as the remote one. But what you haven't seen yet is that you also get a local copy of the last known position of that branch on the remote. The name of that branch includes the name of the remote, origin, since you could have multiple remotes set up, as well as the name of the branch on the remote (in this case, master) with the two separated by a slash (origin/master).

Let's consider what happen when we make a commit on the master branch locally. As usually, when you make a commit on a branch, that branch will get updated to point to the new commit. But, neither the local origin/master branch nor the actually master branch on the GitHub repository will get updated because you haven't communicated that you want to do that. However, if you push the master branch, the local origin/master branch and the remote GitHub branch will get updated with the new commit. Similarly, if this branch were to get updated on GitHub and then we pulled, both of these would get updated with the new commit.

Let's go back to think about what happens when you've got different changes on each repository, with one change locally and another remote. It turns out that you can update just the local copy of the remote branch, leaving your actual local version alone, by running the command "git fetch".

In cases like this, where there are potentially conflicting changes, using "git fetch" to update the local copy of the remote branch can be nice, so that you can use git log and git diff to see what changes were introduced, both on the local and remote repositories. 

This way, if you're going to be offline for a while, say if you're about to get on a plane, you can update your local copy of the remote branch before you leave. And then you'll have access to any updates that have been made to the remote since you last synced up, while you were offline. But you don't have to act on combining those commits right away. 

Combining changes (now that we have the commit from GitHub on our local repository, it's now possible to incorporate them into your master branch using git merge). It turns out that this is exactly what happens when you do a git pull. First, the remote branch gets fetched, updating the local copy of the remote branch. Then, that branch gets merged into the local one. 
-Fetching updates origin/master with the contents of GitHub's master branch
-Then origin/master is merged into master
(git pull origin master => git fetch origin + git merge master origin/master)

-Update local copies by running git fetch origin, which will update all of the local copies of every branch for the origin remote.
-I can inspect the local copies by running "git log origin/master" or "git diff origin/master master".

Merging the Changes Together:





Q. When would you want to use a remote repository rather than keeping all your work local?
A. We may use a remote repository rather than keeping all our work local when we work collaboratively with team members or if we're using different (multiple) computers.

Q. Why might you want to always pull changes manually rather than having Git automatically stay up-to-date with your remote repository?
A. We may not want changes from other people working on the project just yet. Always pulling the changes manually rather than having Git automatically stay up-to-date with our remote repository will give us that control.

Q. Describe the differences between forks, clones, and branches.  When would you use one instead of another?
A. A fork is a GitHub feature that creates a clone of a repository onto its servers (as oppose to cloning it to your local machine). After the fork of a target repository is create onto your GitHub account (which is just a clone of the target repository), you can bring that repository to your local machine by cloning it with the command "git clone [url]" where the url is the forked repository from your GitHub account. The clone is just a copy of a repository. Branches are on a smaller scope, within one repository. We create branched versions of that one repository.




Q. What is the benefit of having a copy of the last known state of the remote stored locally?
A.    Fill in your answer here

Q.How would you collaborate without using Git or GitHub?  What would be easier, and what would be harder?
A.    Fill in your answer here

Q. When would you want to make changes in a separate branch rather than directly in master?  What benefits does each approach have?
A.    Fill in your answer here
