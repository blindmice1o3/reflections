"remote" means a remote repository (Github), and it's something we have to associate with our local Git repository. 

We can see a list of remotes ("git remote") just like we can see a list of branches ("git branch").

"git remote add origin https://github.com/blindmice1o3/reflections.git"
this command creates a remote, it adds a copy of our local repository to our remote (which is labeled as "origin") to a server (the argument with the url).

"git remote -v" -> this command will list all the remotes associated with our local repository, in a verbose manner (shows you more info than regular git remote)

"git push origin master" -> push the commits from my "master" branch onto the remote server labeled "origin"

by default, the branch pushed onto Github will have the same name as the branch from my local repository.

"git pull origin -> like git push, git pull needs to specify the "remote" (which we named "origin"), we also need to specify the branch we want to pull (which is the master branch on the remote)



Forking a repository (e.g. repository storing cooking recipes):
-Co-worker Larry has a repository of recipes (we like his recipes, but we still want to tweak it a little... and save it to share with our friends... but Larry doesn't want our little changes to save over his version of his recipes).
-We can do this on GitHub. We'll clone Larry's repository to Caroline's computer. This would automatically set up Larry's repository as a "remote" called "Origin". Then we could create a new repository on GitHub on Caroline's account. She could then set up this repository as a remote, which she could call whatever she wanted, say Our-version. She can then push the changes to the remote. And then since I (Sarah) want to contribute to this repository as well, I can clone it to my computer, setting up Caroline's version as origin. Anyone looking at our repository on GitHub has no way of knowing Larry's contribution (that it was his initially), unless it was explicitly mentioned.
-To do what we just did, GitHub has a feature called forking. This allows you to make a copy of somebody else's repository directly on the GitHub servers without pulling down the code to your local machine first. 
-You can fork an existing repository and have it appear under your own account with just a single click. Then to make your modifications, you'd likely want to pull down the code onto your own machine, unless the files are simple enough to edit directly on GitHub.
-Forking is a lot like cloning. In fact, a fork is just a clone that GitHub makes for you on their own machines. There are a few other side effects to forking. Like GitHub keeping track of the number of people who've made forks on your repository. And the forks all linking back to the original. It also makes it easier to suggest changes back to the original repository. 
-So since Larry's version is already on GitHub, forking makes a lot of sense in this case. Caroline can make the fork on her account. Then we can each clone our new version. The clones don't need to know anything about the original repository. 


Clone vs Branch vs Fork
-branching happens within the context of one repository.
-cloning is make a copy of the repository from the remote to your local machine (or a copy from your machine to your machine).
-forking is only on GitHub's servers (it makes a clone for you).


To fork the recipe repository, first I'll visit Larry's repository on GitHub. Click the fork button. Then a copy of the repository is made on my own GitHub profile. I'd like to be able to edit these recipes on my own computer rather than just on the GitHub website. So I'll also want to clone this fork. The GitHub page contains the URL I should clone, so I'll copy that URL, and paste it into my git clone command ("git clone [url]"). Then cd (change directory) into the recipes folder. You might think that I need to add the fork on GitHub as a remote so that I'll be able to push it, but actually when you clone a repository... Git automatically sets up a remote pointing to the repository you cloned from. I'll verify that by running "git remote -v". There's a remote called origin and the URL points to my repository on GitHub. Finally, since I want Sarah to be able to collaborate with me, she'll need permission to push to this repository. I'll add her as a collaborator by going to Setting, clicking Collaborators, and then adding her GitHub user name. You don't have to add Sarah to your repository, but this is where you would go to let people push onto your repository. 


Where was your commit present:
			 	BEFORE git push			AFTER git push
In your local repository	YES				YES
(visible via git log)
On your fork 			NO				YES
(visible via the commit history on GitHub)
On Larry's repository		NO				NO
(visible via the commit history on GitHub)

Before you ran git push, your change should have existed locally via git log. Commits will not automatically be shared to remotes, you have to manually push your branch if you want to share changes.
After you ran git push, your change should have existed locally and on your fork. It should not have existed on Larry's repository, which is the repository you forked. The reason you forked in the first place is because you don't have permission to change Larry's repository!

What happens if you had a local commit that hasn't been pushed to GitHub, but also have changes in GitHub (say a coworker contributed, so there's new commits) that aren't on your local machine. If we pull, would we lose our new local commit? What happens if we push when we're in this situation? What we want to happen when we pull is... we want git to keep our new local commits while intergrating the new commits we're pulling from GitHub (we want git to merge the local and remote version of the branch).
-we'll do this by changing the chili-recipe.txt (add a new spice to Ingredient, and change Step 2 to include that ingredient), see the changes using "git diff", add the changes to the staging area "git add chili-recipe.txt, and make a commit (but don't PUSH yet). Now when we run git status I can see my branch is ahead by one commit.
-a collaborator pushed a change to remove cumin from the chili-recipe.txt
-Since Sarah and I both modified the same lines though, Git is going to mark this as a conflict. On the next screen, you'll see some instructions to add Sarah's changes to your own fork. Then Sarah will go over how I can resolve this conflict.

Updating Local Copies of Remote Branches:
When you have a remote set-up, Git stores local copies of all the remote branches. These will each contain the state of the remote branch as of the last time you pushed or pulled the branch. 

We've already seen that when we clone a repository, you get a local branch called master, that points to the same commit as the remote one. 


***
But what you haven't seen yet is that you also get a local copy of the last known position of that branch on the remote. 

The name of that branch includes the name of the remote, origin, since you could have multiple remotes set up, as well as the name of the branch on the remote (in this case, master) with the two separated by a slash (origin/master).
***

*****
Let's consider what happen when we make a commit on the master branch locally. As usually, when you make a commit on a branch, that branch will get updated to point to the new commit. 

But, neither the local origin/master branch nor the actually master branch on the GitHub repository will get updated because you haven't communicated that you want to do that. 

However, if you push the master branch, the local origin/master branch and the remote GitHub branch will get updated with the new commit. 

Similarly, if this branch were to get updated on GitHub and then we pulled, both of these would get updated with the new commit.
*****

Let's go back to think about what happens when you've got different changes on each repository, with one change locally and another remote. It turns out that you can update just the local copy of the remote branch, leaving your actual local version alone, by running the command "git fetch".

In cases like this, where there are potentially conflicting changes, using "git fetch" to update the local copy of the remote branch can be nice, so that you can use git log and git diff to see what changes were introduced, both on the local and remote repositories. 

This way, if you're going to be offline for a while, say if you're about to get on a plane, you can update your local copy of the remote branch before you leave. And then you'll have access to any updates that have been made to the remote since you last synced up, while you were offline. But you don't have to act on combining those commits right away. 

Combining changes (now that we have the commit from GitHub on our local repository, it's now possible to incorporate them into your master branch using git merge). It turns out that this is exactly what happens when you do a git pull. First, the remote branch gets fetched, updating the local copy of the remote branch. Then, that branch gets merged into the local one. 
-Fetching updates origin/master with the contents of GitHub's master branch
-Then origin/master is merged into master
(git pull origin master => git fetch origin + git merge master origin/master)

-Update local copies by running git fetch origin, which will update all of the local copies of every branch for the origin remote.
-I can inspect the local copies by running "git log origin/master" or "git diff origin/master master".

Merging the Changes Together2:
-Since I've already run git fetch, my origin/master will contain Sarah's changes, which I can verify by running git status. As expected, I see that my branch and origin/master have diverged and have one and one different commit each.
-Now I'm ready to merge Sarah's changes into my local master. So, to do that, first I'll make sure I have the master branch checked out. And then I'll run git merge,and the two branches I want to merge are master and origin/master. 
-Like I expected, I got a merge conflict, so I'll open the file and resolve it. 
-So I can see here's the original version (before either of us made changes), here are my changes (with onion powder added), and here's Sarah's version (with cumin removed). I manually resolve the conflict and save the file.
-Finally, I'll let git know the conflict is resolved by adding the chili recipe and committing. 
-As usual, when I merge, Git creates an automatic commit message for me, this time letting me know that I've merged the remote-tracking branch 'origin/master'.
-Since running git pull is the same as running git fetch and then git merge, I could have run git pull origin master and the same thing would have happened.
-If I run this now, then I can see that master is already up-to-date, which makes sense.
-Now create a merged version of your version and Sarah's changes by running either git pull or both git fetch and git merge. Then push the merged version up to GitHub. Once you're finished, run git status and paste the output in this box.

Fast-Forward Merges:
-At this point you might have some questions. You might be wondering if git pull and the same as fetching and merging, why haven't our previous pulls generated commits like this one did? The answer is: fast-forward merges.
-This kind of merge occurs when you merge two commits, where one is ancestor of the other. That is, where one commit is reachable by the other.
-If all merges happened the way we've been showing you so far, if you took b and tried to merge it into a (git merge a b), then you would end up with a merge commit that had both commits as a parent, and you would move a (new a). 
-In the usual case, merge commits are generated to keep track of all the commits that played a part in getting to this stage. But in this case, the commits that played those parts are this one (b) and this one (previous a). And this commit (b) already has all the information about this one's (previous a) history. So there's no actual reason to add this extra one. So instead of adding a new commit, all we would do is update the label to point here (b) instead.
-Hopefully, at this point the name fast-forward merge makes sense.
-We're taking a label from the history of a branch somewhere in its ancestry, and moving that label forward to the tip of the branch. 
-Remember, the only criteria for whether something would be a fast-forward merge is if the branch you are merging into is an ancestor of the branch that you're merging from. 
-(opposite of fast-forward merge is merged commit???)

Reflection question about benefit of having a locally stored copy of the last known state of the remote.

Next, Caroline will introduce a GitHub feature called a "Pull-Request" that makes collaboration easier.

Making a Pull Request:
-Now that you've seen how to make changes public by sharing them on GitHub, I wanted to show you a work flow you can use to get feedback on your changes to a project before you update the master branch. 
-As an example, here is the recipes repository both locally on my own computer and my fork on GitHub. 
-If I have a change I want Sarah's feedback on, then first I'll make that change locally on a separate branch. Next, I'll push that change to my fork. Now my change is shared on GitHub, so Sarah can see it, but it's not in the master branch. That way if Sarah finds a problem with my change when she reviews it, I won't have broken master. 
-Next, I'll use a feature of GitHub called pull requests that make it easy for Sarah to see exactly what I've changed and leave comments.
-When we're both ready, I'll merge this change into the master branch. 
-Right now, I want to change the cake recipe to use canola oil instead of vegetable oil, since it's healthier. 
-First, I'll make a new branch called "different-oil" (git branch different-oil). Then I'll checkout that branch (git checkout different-oil), and go ahead and make the change. Now, I want to show Sarah the changes I've made, so I'll add them (git add cake-recipe.txt), commit them (git commit), and push them (git push origin different-oil). Note that this time I'm running git push origin different-oil to push the different-oil branch instead of master. 
-Now that I've pushed my branch, it's possible to see it on GitHub. To see what branches exist, I can choose this drop down, and I can see that right now I'm looking at the master branch. And here's the different-oil branch that I just pushed. This list of branches is the same list I would see if I ran get branch on the repository on GitHub. So only branches that I've pushed to GitHub will show up. To see what the files look like on the different-oil branch, I can click on it, which is analogous to running git checkout. Sarah could also do this and then view the commit history to see what changes I've made. 
-Instead though, I'm going to create a pull request for my changes. I'll go back to the main page for the repository, and I could click the compare and pull request button here since I just pushed the branch recently. But if I pushed it less recently and that button wasn't there, then I would checkout this branch, scroll down a little and click Pull Request. 
-By default, GitHub assumes I want to merge my changes into the original repository, which is Larry's repository. But instead, I want to merge my changes into the master branch of my own fork. So I'll scroll to the right and click Edit. And now I can change the base fork to cbuckey-uda/recipes. Now I'll scroll down and to the right, and click Create pull request. 
-Now, GitHub makes a view that shows all the commits that are present in this pull request and all the changes that have been made. If I go back up to the repository and scroll to the right, I can also see a list of all Pull Requests. So Sarah can check this list and see that I've liked to merge these changes into master. Now I'll turn you over to Sarah while she looks at my pull request.

-Since I'm watching Caroline's fork of recipes repository, I got an email notifying me when she made a pull request. I can click through in this email to see the pull request on GitHub. You might be wondering why these are called pull requests. 
-Caroline initiated this request, but she's not asking to pull anything. She's trying to merge one of her changes into master, or you might think of this as her trying to "push" into master. So why is it called a "pull request"?
-It's because she's requesting that I pull her branch into the master branch. Another good name for this might be "merge request".
-But "pull request" is what GitHub picked, so we'll go with that.
-So Caroline wants me to merge her different-oil branch into the master branch. Since the master branch is the main branch, and it's what people will see when they first come to the repository, I want to make sure that it really looks good before actually doing the merge. 
-It looks like she just changed vegetable to, oh, "canols"??? I think she meant "canola", based on the name of the pull request.
-I don't really want to merge this in because it has a spelling error. That would probably be confusing if anybody was looking at this later. So instead of merging it now, I'm actually going to leave a comment.
-I could put my comment here, commenting on the whole change, or I could do an inline comment here. I think I'll choose that option. 
-At this point, I'll go back to the main pull request. If there were more commits, I could look at them here, but since there's only one, I don't need to look at anything else. 
-If I had decided that the change was good, and ready to be pulled in right now, I could have pressed this Merge pull request button. 
-This will only appear when the merge could go through without a conflict. So it's a nice indicator to the person reviewing the changes, as to whether or not it's really ready to go. If the change would've created a merge conflict, I would ask Caroline to merge master into her branch first, so that I could see how she resolves the conflict. That way I know that when her code finally does get added to master, there's no chance that something's going to go wrong with a bad merge. 
-All right, at this point you should go ahead and make the change that Caroline described by creating a new branch off of master, and commiting a change that switches vegetable oil out in favor of canola. You can make a typo or other mistake on purpose so that you'll have a reason to update the pull request later. You don't have to. Go ahead and push your new branch to the fork, and then use GitHub to initiate a pull request, but make sure not to click the Merge button yet. 


Updating a Pull Request:
-



Q. When would you want to use a remote repository rather than keeping all your work local?
A. We may use a remote repository rather than keeping all our work local when we work collaboratively with team members or if we're using different (multiple) computers.

Q. Why might you want to always pull changes manually rather than having Git automatically stay up-to-date with your remote repository?
A. We may not want changes from other people working on the project just yet. Always pulling the changes manually rather than having Git automatically stay up-to-date with our remote repository will give us that control.

Q. Describe the differences between forks, clones, and branches.  When would you use one instead of another?
A. A fork is a GitHub feature that creates a clone of a repository onto its servers (as oppose to cloning it to your local machine). After the fork of a target repository is create onto your GitHub account (which is just a clone of the target repository), you can bring that repository to your local machine by cloning it with the command "git clone [url]" where the url is the forked repository from your GitHub account. The clone is just a copy of a repository. Branches are on a smaller scope, within one repository. We create branched versions of that one repository.

Q. What is the benefit of having a copy of the last known state of the remote stored locally?
A. The benefit of having a copy of the last known state of the remote stored locally is you can be offline and still be able to compare (git diff) your present working copy with the last known remote changes.




Q.How would you collaborate without using Git or GitHub?  What would be easier, and what would be harder?
A.    Fill in your answer here

Q. When would you want to make changes in a separate branch rather than directly in master?  What benefits does each approach have?
A.    Fill in your answer here
